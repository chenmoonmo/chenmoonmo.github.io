<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="js高级程序设计读书笔记"><meta name="keywords" content="读书笔记"><meta name="author" content="chenmoonmo@gmail.com"><meta name="copyright" content="chenmoonmo@gmail.com"><title>js高级程序设计读书笔记 | Chenmoonmo's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-在HTML中使用JavaScript"><span class="toc-number">1.</span> <span class="toc-text">2.在HTML中使用JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lt-script-gt-元素"><span class="toc-number">1.0.1.</span> <span class="toc-text">&lt;script&gt;元素</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#标签位置"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">标签位置</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-基本概念"><span class="toc-number">2.</span> <span class="toc-text">3.基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#语法"><span class="toc-number">2.0.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关键字和保留字"><span class="toc-number">2.0.2.</span> <span class="toc-text">关键字和保留字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变量"><span class="toc-number">2.0.3.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据类型"><span class="toc-number">2.0.4.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#typeof操作符"><span class="toc-number">2.0.4.1.</span> <span class="toc-text">typeof操作符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Undefined类型"><span class="toc-number">2.0.4.2.</span> <span class="toc-text">Undefined类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Null类型"><span class="toc-number">2.0.4.3.</span> <span class="toc-text">Null类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Boolean类型"><span class="toc-number">2.0.4.4.</span> <span class="toc-text">Boolean类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Number类型"><span class="toc-number">2.0.4.5.</span> <span class="toc-text">Number类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#浮点数"><span class="toc-number">2.0.4.6.</span> <span class="toc-text">浮点数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#数值范围"><span class="toc-number">2.0.4.7.</span> <span class="toc-text">数值范围</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NaN"><span class="toc-number">2.0.4.8.</span> <span class="toc-text">NaN</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#数值转换"><span class="toc-number">2.0.4.9.</span> <span class="toc-text">数值转换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String类型"><span class="toc-number">2.0.5.</span> <span class="toc-text">String类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#字符字面量"><span class="toc-number">2.0.5.1.</span> <span class="toc-text">字符字面量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#字符串的特点"><span class="toc-number">2.0.5.2.</span> <span class="toc-text">字符串的特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#转换为字符串"><span class="toc-number">2.0.5.3.</span> <span class="toc-text">转换为字符串</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object类型"><span class="toc-number">2.0.6.</span> <span class="toc-text">Object类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#创建对象"><span class="toc-number">2.0.6.1.</span> <span class="toc-text">创建对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Object"><span class="toc-number">2.0.6.2.</span> <span class="toc-text">Object</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#操作符"><span class="toc-number">2.0.7.</span> <span class="toc-text">操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#一元操作符"><span class="toc-number">2.0.7.1.</span> <span class="toc-text">一元操作符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#递增和递减"><span class="toc-number">2.0.7.2.</span> <span class="toc-text">递增和递减</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#一元加和减操作符"><span class="toc-number">2.0.7.3.</span> <span class="toc-text">一元加和减操作符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#布尔操作符"><span class="toc-number">2.0.7.4.</span> <span class="toc-text">布尔操作符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#乘性操作符"><span class="toc-number">2.0.7.5.</span> <span class="toc-text">乘性操作符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#加性操作符"><span class="toc-number">2.0.7.6.</span> <span class="toc-text">加性操作符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#关系比较符"><span class="toc-number">2.0.7.7.</span> <span class="toc-text">关系比较符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#相等操作符"><span class="toc-number">2.0.7.8.</span> <span class="toc-text">相等操作符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#条件操作符"><span class="toc-number">2.0.7.9.</span> <span class="toc-text">条件操作符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#赋值表达式"><span class="toc-number">2.0.7.10.</span> <span class="toc-text">赋值表达式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#逗号操作符"><span class="toc-number">2.0.7.11.</span> <span class="toc-text">逗号操作符</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#语句"><span class="toc-number">2.0.8.</span> <span class="toc-text">语句</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#if语句"><span class="toc-number">2.0.8.1.</span> <span class="toc-text">if语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#do-while语句"><span class="toc-number">2.0.8.2.</span> <span class="toc-text">do-while语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#while语句"><span class="toc-number">2.0.8.3.</span> <span class="toc-text">while语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#for语句"><span class="toc-number">2.0.8.4.</span> <span class="toc-text">for语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#for-in语句"><span class="toc-number">2.0.8.5.</span> <span class="toc-text">for-in语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#label语句"><span class="toc-number">2.0.8.6.</span> <span class="toc-text">label语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#break和continue语句"><span class="toc-number">2.0.8.7.</span> <span class="toc-text">break和continue语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#switch语句"><span class="toc-number">2.0.8.8.</span> <span class="toc-text">switch语句</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数"><span class="toc-number">2.0.9.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#定义函数"><span class="toc-number">2.0.9.1.</span> <span class="toc-text">定义函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#理解参数"><span class="toc-number">2.0.9.2.</span> <span class="toc-text">理解参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#没有重载"><span class="toc-number">2.0.9.3.</span> <span class="toc-text">没有重载</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-变量、作用域和内存问题"><span class="toc-number">3.</span> <span class="toc-text">4.变量、作用域和内存问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本类型和引用类型的值"><span class="toc-number">3.0.1.</span> <span class="toc-text">基本类型和引用类型的值</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#动态的属性"><span class="toc-number">3.0.1.1.</span> <span class="toc-text">动态的属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#复制变量值"><span class="toc-number">3.0.1.2.</span> <span class="toc-text">复制变量值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#传递参数"><span class="toc-number">3.0.1.3.</span> <span class="toc-text">传递参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#检测类型"><span class="toc-number">3.0.1.4.</span> <span class="toc-text">检测类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#执行环境及作用域"><span class="toc-number">3.0.2.</span> <span class="toc-text">执行环境及作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#没有块级作用域"><span class="toc-number">3.0.2.1.</span> <span class="toc-text">没有块级作用域</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#垃圾清理"><span class="toc-number">3.0.3.</span> <span class="toc-text">垃圾清理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#标记清除"><span class="toc-number">3.0.3.1.</span> <span class="toc-text">标记清除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#管理内存"><span class="toc-number">3.0.3.2.</span> <span class="toc-text">管理内存</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-引用类型"><span class="toc-number">4.</span> <span class="toc-text">5.引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Object类型-1"><span class="toc-number">4.0.1.</span> <span class="toc-text">Object类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#创建Object实例"><span class="toc-number">4.0.1.1.</span> <span class="toc-text">创建Object实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#访问对象属性"><span class="toc-number">4.0.1.2.</span> <span class="toc-text">访问对象属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Array类型"><span class="toc-number">4.0.2.</span> <span class="toc-text">Array类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#创建数组"><span class="toc-number">4.0.2.1.</span> <span class="toc-text">创建数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#检测数组"><span class="toc-number">4.0.2.2.</span> <span class="toc-text">检测数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#转换方法"><span class="toc-number">4.0.2.3.</span> <span class="toc-text">转换方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#栈方法"><span class="toc-number">4.0.2.4.</span> <span class="toc-text">栈方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#队列方法"><span class="toc-number">4.0.2.5.</span> <span class="toc-text">队列方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#重排序方法"><span class="toc-number">4.0.2.6.</span> <span class="toc-text">重排序方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#操作方法"><span class="toc-number">4.0.2.7.</span> <span class="toc-text">操作方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#位置方法"><span class="toc-number">4.0.2.8.</span> <span class="toc-text">位置方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#迭代方法"><span class="toc-number">4.0.2.9.</span> <span class="toc-text">迭代方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#归并方法"><span class="toc-number">4.0.2.10.</span> <span class="toc-text">归并方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ES6新增"><span class="toc-number">4.0.2.11.</span> <span class="toc-text">ES6新增</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Date类型"><span class="toc-number">4.0.3.</span> <span class="toc-text">Date类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#创建日期对象"><span class="toc-number">4.0.3.1.</span> <span class="toc-text">创建日期对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#继承的方法"><span class="toc-number">4.0.3.2.</span> <span class="toc-text">继承的方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#实例的常用方法"><span class="toc-number">4.0.3.3.</span> <span class="toc-text">实例的常用方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RegExp"><span class="toc-number">4.0.4.</span> <span class="toc-text">RegExp</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#创建正则表达式"><span class="toc-number">4.0.4.1.</span> <span class="toc-text">创建正则表达式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#实例方法"><span class="toc-number">4.0.4.2.</span> <span class="toc-text">实例方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Function类型"><span class="toc-number">4.0.5.</span> <span class="toc-text">Function类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#定义函数-1"><span class="toc-number">4.0.5.1.</span> <span class="toc-text">定义函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#函数的内部属性"><span class="toc-number">4.0.5.2.</span> <span class="toc-text">函数的内部属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#函数的属性和方法"><span class="toc-number">4.0.5.3.</span> <span class="toc-text">函数的属性和方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基本包装类型"><span class="toc-number">4.0.6.</span> <span class="toc-text">基本包装类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Boolean类型-1"><span class="toc-number">4.0.6.1.</span> <span class="toc-text">Boolean类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Number-类型"><span class="toc-number">4.0.6.2.</span> <span class="toc-text">Number 类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#String类型-1"><span class="toc-number">4.0.6.3.</span> <span class="toc-text">String类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Global对象"><span class="toc-number">4.0.6.4.</span> <span class="toc-text">Global对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Math对象"><span class="toc-number">4.0.6.5.</span> <span class="toc-text">Math对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-面向对象的程序设计"><span class="toc-number">4.0.7.</span> <span class="toc-text">6.面向对象的程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#数据属性-包含一个数据值的位置，在这个位置可以读取和写入值，有4个描述其行为的特性"><span class="toc-number">4.0.7.1.</span> <span class="toc-text">数据属性 包含一个数据值的位置，在这个位置可以读取和写入值，有4个描述其行为的特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#访问器属性-包含一对getter和setter函数，不包含数值-这两个函数非必须"><span class="toc-number">4.0.7.2.</span> <span class="toc-text">访问器属性 包含一对getter和setter函数，不包含数值(这两个函数非必须)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#读取属性"><span class="toc-number">4.0.7.3.</span> <span class="toc-text">读取属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#创建对象-1"><span class="toc-number">4.0.7.4.</span> <span class="toc-text">创建对象</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars1.githubusercontent.com/u/36295999?s=460&amp;u=2abb59fe554eee63b4bca78d6ec82499e7bd1096&amp;v=4"></div><div class="author-info__name text-center">chenmoonmo@gmail.com</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">15</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">8</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Chenmoonmo's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/about">About</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">js高级程序设计读书笔记</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-24</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>JavaScript分为ECMAScript, DOM和BOM。</p>
<h2 id="2-在HTML中使用JavaScript"><a href="#2-在HTML中使用JavaScript" class="headerlink" title="2.在HTML中使用JavaScript"></a>2.在HTML中使用JavaScript</h2><h4 id="lt-script-gt-元素"><a href="#lt-script-gt-元素" class="headerlink" title="&lt;script&gt;元素"></a><code>&lt;script&gt;</code>元素</h4><p>具有以下属性：</p>
<ul>
<li>async：可选，表示立即下载脚本但不妨碍页面其他操作。</li>
<li>charset:：可选，表示通过src指定代码的字符集，不常用。</li>
<li>defer：可选，表示脚本可以延迟到文档完全被解析和显示之后再执行，只对外部脚本有效。</li>
<li>src：可选，表示引入外部文件。</li>
<li>type：必选，一般为text/javascript。</li>
</ul>
<h5 id="标签位置"><a href="#标签位置" class="headerlink" title="标签位置"></a>标签位置</h5><p>避免页面加载出现延迟，<code>&lt;script&gt;</code>标签放在body结束之前，页面结构之后。</p>
<h2 id="3-基本概念"><a href="#3-基本概念" class="headerlink" title="3.基本概念"></a>3.基本概念</h2><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ul>
<li>区分大小写：ECMAScript中的一切都区分大小写</li>
<li>标识符：变量、函数、属性的名字或函数的参数。可以是按照以下规则组合而成的一个或多个字符：<ul>
<li>第一个字符必须是字母、下划线(_)或一个美元符号</li>
<li>其他字符可以是字母、下划线或数字</li>
<li>按照惯例，标识采用驼峰大小写格式，第一个字母小写，剩下每个单词的首字母大写</li>
</ul>
</li>
<li>注释：<ul>
<li>单行注释： //</li>
<li>多行注释：/*… */</li>
</ul>
</li>
<li>严格模式：在需要开启严格模式的作用域顶部添加<code>&quot;use strict&quot;</code></li>
<li>语句：ECMAScript中的语句以一个分号结尾，如果省略分号，则由解析器确定语句的结尾。可以用花括号{}将多条语句组合到一个代码块内。</li>
</ul>
<h4 id="关键字和保留字"><a href="#关键字和保留字" class="headerlink" title="关键字和保留字"></a>关键字和保留字</h4><p>关键字：不能用做变量、函数、过程和对象名</p>
<p>break case catch continue default delete do else finally for function if in instanceof new return switch this throw try typeof var void while with</p>
<p>保留字：未来可能作为关键字</p>
<p>abstract boolean byte char class const debugger double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>ECMAScript的变量是松散类型的，可以保存任何类型的数据，每个变量只是一个用于保存值的占位符。</p>
<p>可以使用var, let和const来声明变量。</p>
<ul>
<li>var 变量提升 允许重复声明 不需要初始值 不存在暂时性死区</li>
<li>let 没有变量提升 不允许重复声明 不需要初始值 存在暂时性死区</li>
<li>const  没有变量提升 不允许重复声明 需要初始值 存在暂时性死区</li>
</ul>
<p>在函数中声明的变量，在函数执行之后就被销毁，外部作用域无法访问到。</p>
<p>不使用操作符号可以声明一个全局变量，但不推荐。</p>
<p>可以使用一条语句声明多个变量，使用逗号隔开。</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul>
<li>5种简单类型： Undefined,Null,Boolean,Number和String</li>
<li>1种复杂类型： Object</li>
</ul>
<h5 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a><code>typeof操作符</code></h5><p>返回给定变量的数据类型字符串，该操作符的操作数可以是变量，也可以是数字字面量，返回值如下：</p>
<ul>
<li>“undefined”—变量为定义</li>
<li>“boolean”—布尔值</li>
<li>“string”—字符串</li>
<li>“unmber”—数值</li>
<li>“object”—对象或null</li>
<li>“function”—函数</li>
</ul>
<h5 id="Undefined类型"><a href="#Undefined类型" class="headerlink" title="Undefined类型"></a>Undefined类型</h5><p>Undefined类型只有一个值，即特殊的undefined，当一个变量使用var声明但未初始化时，这个变量的值就是undefined。也可以主动给变量赋值为undefined，但没必要。</p>
<p>未声明的变量的值也为undefined，不过，包含undefined值的变量和尚未定义的变量还是不一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var message</span><br><span class="line">console.log(message) &#x2F;&#x2F; undefined</span><br><span class="line">console.log(mes) &#x2F;&#x2F; mes为定义 报错</span><br></pre></td></tr></table></figure>

<p>但未定义的值可以使用typeof操作符，返回它的数据类型 undefined。</p>
<h5 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h5><p>Null类型也只有一个值，即null，表示一个<strong>空对象指针</strong>，这也是使用typeof操作符检测null会返回object的原因。</p>
<p>如果定义的变量准备用来保存对象，最好将改变了初始化为null。</p>
<p>实际上，undefined值是派生自null值的，所以使用相等操作符(==)进行比较时，总是返回true。</p>
<h5 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h5><p>Boolean类型有两个字面量：true 和false （区分大小写）</p>
<p>虽然Boolean类型的字面量只有两个，但ECMAScript中所有类型的值都有和这两个Boolean值等价的值，使用转型函数<code>Boolean()</code>将其他值转为对应的值，规则如下：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>转换为true的值</th>
<th>转换为false的值</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>任何非空字符</td>
<td>“”</td>
</tr>
<tr>
<td>Number</td>
<td>任何非0数值</td>
<td>0和NaN</td>
</tr>
<tr>
<td>Object</td>
<td>任何对象</td>
<td>null</td>
</tr>
<tr>
<td>Undefined</td>
<td>无</td>
<td>undefined</td>
</tr>
</tbody></table>
<p>在if条件判断语句中，会自动执行Boolean()转型函数。</p>
<h5 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h5><p>支持整数和浮点数。</p>
<p>可以表示不同进制的数：</p>
<ul>
<li>十进制</li>
<li>八进制 以0开头</li>
<li>十六进制 以0x开头</li>
</ul>
<h5 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h5><p>数值中包含一个小数点，小数点后必须有至少一个数字。</p>
<p>科学计数法：使用科学计数法的值为e前面的浮点数 乘以 10的e后面的数的幂。</p>
<p>浮点数的最高精度时17为小数，但运算精确度不如整数，如0.1+0.2的结果不为0.3。</p>
<h5 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h5><p>ECMAScript的最小数值为 Number.MIN_VALUE，最大数值为Number.MAX_VALUE。</p>
<p>超过这两个数值的数，会被表示为Infinity和-Infinity。可以通过isFInite()函数来判断参数是否在允许范围内，在参数介于最大值和最小值之间时，会返回true。</p>
<h5 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h5><p>NaN，即非数值，任何数值除以非数值都会返回NaN。</p>
<p>涉及NaN的操作都会返回NaN，NaN和任何值都不相等，包括NaN本身。</p>
<p>isNaN()函数，接受一个任何类型的参数，判断其是否”不是数值”，如果不能转换为数值或值为NaN，则返回true。</p>
<h5 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h5><p>有3个函数可以将非数值转换为数值：</p>
<ul>
<li><p>Number()：</p>
<ul>
<li>Blooean值：true和false分别被转换为1和0</li>
<li>数字值：简单的传入和返回</li>
<li>null值：返回0</li>
<li>undefined：返回NaN</li>
<li>字符串：<ul>
<li>只包含数字则将其转换为十进制数</li>
<li>包含有效的浮点数则将其转换为对应的浮点数</li>
<li>字符串中包含有效的十六进制格式，则将其转换为相应的十进制数值</li>
<li>如果字符串为空，则转换为0</li>
<li>如果字符串中包含上述格之外的数值，则转换为NaN</li>
</ul>
</li>
<li>对象：调用对象的valueof()方法，然后按照前面的规则转换返回的值，如果转换的结果是NaN，则调用对象的toSting()方法，再按前面的规则转换返回的字符串值。</li>
</ul>
</li>
<li><p>parseInt(string, radix)：</p>
<p>处理整数时更常用，将一个字符串 string 转换为 radix 进制的整数,规则如下：</p>
<ul>
<li>忽略字符串前面的空格，直到找到第一个非空字符</li>
<li>如果第一个非空字符不是数字字符或者负号，则返回NaN</li>
<li>如果第一个字符是数字字符，则继续解析第二个字符，直到解析完后续字符或者遇到了第一个非数字字符。</li>
<li>不传递第二个参数时，parseInt()也能解析出0x开头的十六进制,并返回相应的十进制值。</li>
<li>parseInt的第二个参数为转换时该数的进制，返回相应的十进制值，如果是十六进制，前面可以没有0x。</li>
</ul>
</li>
</ul>
<p>建议在任何情况下都为parseInt指定基数。</p>
<ul>
<li><p>parseFloat():</p>
<p>处理整数时更常用，将一个字符串 string 转换为 radix 进制的整数,规则如下：</p>
<ul>
<li>从第1个字符开始解析，直到字符串末尾或者是第一个无效浮点数数字字符为止。</li>
<li>始终会忽略前导的0。</li>
<li>十六进制的字符串始终会被解析为0。</li>
<li>只解析十进制值。</li>
</ul>
</li>
</ul>
<h4 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h4><p>用于表示由0到多个字符组成的字符序列，可以由’或”表示。</p>
<h5 id="字符字面量"><a href="#字符字面量" class="headerlink" title="字符字面量"></a>字符字面量</h5><p>特殊的字符字面量 用于表示非打印字符，或具有其他用途的字符</p>
<ul>
<li>\n 换行</li>
<li>\t 制表</li>
<li>\b 退格</li>
<li>\r 回车</li>
<li>\f 进纸</li>
<li>\\ 斜杠</li>
<li>\‘ 单引号</li>
<li>\“ 双引号</li>
<li>\xnn 十六进制代码nn表示的一个字符</li>
<li>\unnn 十六进制代码nnnn表示的一个Unicode字符</li>
</ul>
<p>字符串的长度可以通过length属性取得，长度会包含转义字符的长度</p>
<h5 id="字符串的特点"><a href="#字符串的特点" class="headerlink" title="字符串的特点"></a>字符串的特点</h5><p>字符串一旦创建，他们的值就不能改变，要改变某个变量保存的字符串，首先要销毁原来的字符串，再用另一个包含新值的字符串填充该变量，这个过程在后台发生。</p>
<h5 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h5><ul>
<li>toString(): 数值、布尔值、对象和字符串都有toString()方法。该方法可以传递一个参数：输出值的基数，可以输出任意有效进制的数字字符串。</li>
<li>String(): 转型函数，在不知道转换值是不是null或undefined时使用。可以将任何类型的值转换为字符串：<ul>
<li>如果值有toString()方法，则调用该方法</li>
<li>如果值为null，则返回”null”</li>
<li>如果值为undefined，则返回”undefined”</li>
</ul>
</li>
</ul>
<p>补充：对象的toString()方法可以返回类型字符串”[object Object]”</p>
<p>使用Object.prototype.toString.call() 可以判断值的具体类型</p>
<h4 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h4><p>对象是一组数据和功能的集合，可以通过执行new操作符后跟要创建的对象类型名称来创建。</p>
<h5 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h5><ul>
<li><code>let obj = new Object(...)</code> // 创建Object的实例</li>
<li><code>let obj = {...}</code>  //字面量创建</li>
</ul>
<h5 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h5><p>Object类型是所有它的实例的基础，Object类型具有的任何属性和方法，也同样存在于更具体的对象，下面是Object的属性和方法：</p>
<ul>
<li>constructor: 保存着用于创建当前对象的函数，对于对象来说，就是Object()。</li>
<li>hasOwnProperty(porpertyName): 检查给定的属性在当前对象实例(而不是实力的原型)中是否存在，propertyName必须以字符串形式指定。</li>
<li>isPrototypeOf(object): 用于检查传入的对象是否是当前对象的原型。</li>
<li>propertyIsEnumerable(propertyName): 用于检查给定的属性是否能够使用for-in语句枚举。</li>
<li>toLocaleString(): 返回对象的字符串表示，和该对象执行环境所在的地区对应</li>
<li>toString(): 返回对象的字符串表示。</li>
<li>valueOf(): 返回对象的字符串、数值或布尔值表示，通常和toSting()方法返回值相同。</li>
</ul>
<h4 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h4><p>算术操作符、位操作符、关系操作符和相等操作符</p>
<h5 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h5><p>只能操作一个值的叫做一元操作符。</p>
<h5 id="递增和递减"><a href="#递增和递减" class="headerlink" title="递增和递减"></a>递增和递减</h5><p>有前置型和后置型两种，作用是给一个数值加1。</p>
<p>执行前置递增操作时，变量的值都是在语句被求值之前改变的，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let age &#x3D; 29</span><br><span class="line">let anotherAge &#x3D; --age + 2</span><br><span class="line">console.log(age) &#x2F;&#x2F;28</span><br><span class="line">console.log(anotherAge) &#x2F;&#x2F; 30</span><br></pre></td></tr></table></figure>

<p>后置型递增递减操作符是在包含他们的语句被求值之后才执行的。</p>
<p>这4个操作符对任何值都适用，会对其他类型的值进行隐式转换后再机进行操作：</p>
<ul>
<li>包含有效数字的字符串：先转换为数字值，再执行加减1操作。</li>
<li>不包含有效数字的字符串：将变量的值设置为NaN。</li>
<li>布尔值false： 先转换为0，再加减1。</li>
<li>布尔值true：先转换为1，再加减1。</li>
<li>浮点数：执行加减1。</li>
<li>对象： 先调用对象的valueOf()方法取得一个可操作的值，再对该值应用上述规则。如果结果是NaN，则调用toString()方法后再应用上述规则。</li>
</ul>
<h5 id="一元加和减操作符"><a href="#一元加和减操作符" class="headerlink" title="一元加和减操作符"></a>一元加和减操作符</h5><p>一元加操作符：放在数值前面，对数值不会起任何作用，对非数值有类型转换的作用。</p>
<p>一元减操作符： 主要用于表示负数，也可以用于非数值的数据转换。</p>
<h5 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h5><p>用于测试两个值的关系，一共有三个，分别为非、与、或。</p>
<ul>
<li><p>逻辑非，由一个叹号(!)表示，可以应用于ECMAScript中的任何值，无论这个值是什么类型，都会返回一个布尔值。逻辑非先将它的操作数转换为一个布尔值，在对其求反，遵循以下操作：</p>
<ul>
<li>对象： false</li>
<li>空字符串： true</li>
<li>非空字符串：false</li>
<li>数值0： true</li>
<li>任意非0数值： false</li>
<li>null：true</li>
<li>undefined： true</li>
<li>NaN：true</li>
</ul>
<p>同时使用两个逻辑非操作符就能模拟Boolean()转型函数的行为。</p>
</li>
<li><p>逻辑与，由两个和号(&amp;&amp;)表示，有两个操作数，全真则真，一假则假，在有一个操作数不是布尔值的情况下，逻辑与操作不一定返回布尔值，遵循规则如下：</p>
<ul>
<li>第一个操作数是对象：返回第二个操作数</li>
<li>第二个操作数是对象：第一个操作数求值为true时，才返回该对象</li>
<li>两个操作数都是对象：返回第二个操作数</li>
<li>第一个操作数是null：返回null</li>
<li>第一个操作数是NaN：返回NaN</li>
<li>第一个操作数是undefined，返回undefined</li>
</ul>
<p><strong>逻辑与属于短路操作，即如果第一个操作数能决定结果，那么就不会对第二个操作数求值，对于逻辑与操作，如果第一个操作数为false，则无论第二个操作数是什么值，结果都不可能是true</strong></p>
<p>不能在逻辑与中使用未定义的值。</p>
</li>
<li><p>逻辑或，由两个竖线符号(||)表示，一真则真，全假则假，在有一个操作数不是布尔值的情况下，也不一定返回布尔值，规则如下：</p>
<ul>
<li>第一个操作数是对象：返回第一个操作数</li>
<li>第一个操作数求值为false：返回第二个操作数</li>
<li>两个操作数都是对象：返回第一个操作数</li>
<li>两个操作数都是null：返回null</li>
<li>两个操作数都是NaN：返回NaN</li>
<li>两个操作数都是undefined：返回undefined</li>
</ul>
<p>逻辑或也是短路操作符，如果第一个操作数的结果为true，就不会对第二个操作数求值。</p>
<p>我们可以利用逻辑或的这一行为来避免给变量赋null或undefined值。</p>
</li>
</ul>
<h5 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h5><ul>
<li>乘法：乘法操作符由一个星号(*)表示，用于计算两个数值的乘积，在处理特殊值的情况下，遵循以下规则：<ul>
<li>如果操作数都是数值，执行常规的乘法计算，如果乘积超过ECMAScript数值的表示范围，则返回Infinity或-Infinity</li>
<li>如果有一个操作数是NaN，则返回NaN</li>
<li>如果是Infinity和0相乘，则结果是NaN</li>
<li>如果是Infinity和非0数值相乘，则结果是Infinity</li>
<li>如果是Infinity和Infinity相乘，则结果是Infinity</li>
<li>如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，再应用上面的规则</li>
</ul>
</li>
<li>除法：除法符号由一个斜线(/)表示，执行第二个操作数除第一个操作数的计算，规则如下：<ul>
<li>如果操作数都是数值，则进行正常的除法计算，如果商超过ECMAScript的数值表示范围，则返回Infinity或-Infinity</li>
<li>如果有一个操作数是NaN，则结果为NaN</li>
<li>如果是Infinity被Infinity除，则结果为NaN</li>
<li>如果是0被0除，则结果为NaN</li>
<li>如果是非零的有限数被0除，则结果是Infinity或-Infinity，取决于有符号操作数的符号</li>
<li>如果是Infinity被任何非0数值除，则结果是Infinity或-Infinity。</li>
<li>如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，再应用上面的规则</li>
</ul>
</li>
<li>求模：求模(余数)操作符由一个百分号(%)表示，用法如下：<ul>
<li>如果两个操作数都是数值，执行常规的除法计算，返回除得的余数</li>
<li>如果被除数是无穷大值，而除数是有限大的值，则结果是NaN</li>
<li>如果被除数是有限大值，而除数是0，则结果为NaN</li>
<li>如果是Infinity被Infinity除，则结果是NaN</li>
<li>如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数</li>
<li>如果被除数是0，则结果是0</li>
<li>如果有一个操作数不是数值，则在后台调用Number()将其转为数值，再应用上面的规则</li>
</ul>
</li>
</ul>
<h5 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h5><ul>
<li>加法：由加号(+)表示，规则如下：<ul>
<li>如果有一个操作数是NaN，则结果为NaN</li>
<li>如果是Infinity加Infinity，则结果是Infinity</li>
<li>如果是-Infinity加-Infinity，则结果是-Infinity</li>
<li>如果是Infinity加-Infinity，则结果是NaN</li>
<li>+0 + +0，+0</li>
<li>-0 + -0，-0</li>
<li>+0 + -0，+0</li>
<li>如果有一个操作符是字符串，就应用如下规则：<ul>
<li>如果两个操作符都是字符串，则拼接两个操作数</li>
<li>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接起来</li>
<li>如果有一个操作数是对象、数值或布尔值，则调用他们的toString()方法取得相应的字符串值，再应用前面的规则</li>
<li>对于null和undefined，则分别调用String() 函数并取得相应的字符串”null” “undefined”</li>
</ul>
</li>
</ul>
</li>
<li>减法：由减号(-)表示，规则和加法操作类似，区别在于遇到字符串时，规则如下：<ul>
<li>如果一个操作数时字符串、布尔值、null或undefined，则在后台调用Number()函数将其转换为数值，然后再更具前面的规则执行减法操作，如果转换的结果为NaN，则减法的结果就是NaN。</li>
<li>如果有一个操作数时对象，则调用对象的valueOf()方法取得表示该对象的数值，如果得到的值是NaN，则减法的结果就是NaN，如果对象没有valueOf()方法，则调用其toString()方法，并将提取到的字符串转为数值。</li>
</ul>
</li>
</ul>
<h5 id="关系比较符"><a href="#关系比较符" class="headerlink" title="关系比较符"></a>关系比较符</h5><p>小于(&lt;)，大于(&gt;)，小于等于(&lt;=)，大于等于(&gt;=)这几个关系操作符用于对两个值进行比较，当关系操作数由非数值时，也会进行数据转换，规则如下：</p>
<ul>
<li>如果两个操作数都是数值，则执行数值比较</li>
<li>如果两个操作数都是字符串，则比较两个字符串对应的字符编码值</li>
<li>如果一个操作数是数值，则将另一个操作数转换为数值，然后进行比较</li>
<li>如果一个操作数是对象，则调用这个对象的valueOf()方法，并用得到的结果根据前面的规则进行比较</li>
<li>如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较</li>
</ul>
<p>在进行字符串比较时，大写字母的编码全部小于小写字母的编码，如果真正要按字母表顺序比较字符串，就必须吧两个操作数转换为相同的大小写。</p>
<p>在比较两个数字字符串时，也比较的是字符编码。</p>
<p>不含数值的字符串和数字比较时，字符串被转换为NaN，返回值始终为false。</p>
<h5 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h5><ul>
<li><p>相等(==)和不相等(!=)，这两个操作符都会先转换操作数，再比较它们的相等性</p>
<ul>
<li>布尔值，true转换为1，false转换为0</li>
<li>字符串和数值比较，将字符串转换成数值</li>
<li>一个操作数是对象，另一个不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较</li>
</ul>
<p>这两个操作符再进行比较时还要遵循以下规则：</p>
<ul>
<li>null和undefined相等</li>
<li>要比较相等性时，不能将null和undefined转换为其他任何值</li>
<li>如果有一个操作数时NaN，则相等操作符返回false，不相等操作符返回true</li>
<li>NaN不等于NaN</li>
<li>如果两个操作数指向同一个对象，则相等操作符返回true，否则返回false</li>
</ul>
</li>
<li><p>全等(===)和不全等(!==)，在比较时不会转换操作数，而null === undefined会返回false，</p>
<p>更推荐使用全等和不全等操作符</p>
</li>
</ul>
<h5 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h5><p>即三元表达式，<code>variable = boolean_expression ? true_value: false_value ;</code></p>
<p>这行代码对boolean_expression求值，如果结果为true，则给变量赋值true_value，如果结果为false，则给变量赋值false_value。</p>
<h5 id="赋值表达式"><a href="#赋值表达式" class="headerlink" title="赋值表达式"></a>赋值表达式</h5><ul>
<li>赋值 = ，将左边的值赋值给右边的变量</li>
<li>乘赋值 *=，将左边的值乘以右边变量的值的结果赋值给右边的变量</li>
<li>除赋值 /=</li>
<li>加赋值 +=</li>
<li>减赋值 -=</li>
<li>模赋值 %=</li>
</ul>
<h5 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h5><p>使用逗号操作符可以在一条语句中执行多个操作，在用于赋值时，逗号操作符总会返回表达式的最后一项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let num &#x3D; (1,2,3,4,0) &#x2F;&#x2F; num &#x3D; 0</span><br></pre></td></tr></table></figure>

<h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><h5 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h5><p>if(condition) {statement1} else if(condition) {statement2} else {statement}</p>
<h5 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do-while语句"></a>do-while语句</h5><p>do-while语句是一种后测试语句，循环体内的代码至少会被执行一次</p>
<p>do{statement} while(expression)</p>
<p>当expression为true时，循环就会一直继续下去</p>
<h5 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h5><p>while语句时一种前测试语句，循环体内的代码可能永远不会被执行</p>
<p>while(expression) {statement}</p>
<h5 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h5><p>for(initialization; expression; post-loop-expression) {statement}</p>
<p>使用while循环做不到的，使用for循环也做不到。在for循环的变量初始化表达式中，也可以不使用var关键字。该变量的初始化可以在外部执行。在循环内部定义的变量也可以在外部访问到。</p>
<p>将for的三个表达式全部省略，就会创建一个无限循环。</p>
<h5 id="for-in语句"><a href="#for-in语句" class="headerlink" title="for-in语句"></a>for-in语句</h5><p>for-in语句是一种精准的迭代语句，可以用来枚举对象的属性。</p>
<p>for(property in expression) {statement}</p>
<p>ECMAScript对象的属性没有顺序，因此通过for-in循环输出的属性名的顺序是不可预测的。</p>
<p>如果表示要迭代的对象的变量值为null或undefined，循环体不会执行，建议在循环前先检测确认该对象的值不是null或undefined</p>
<h5 id="label语句"><a href="#label语句" class="headerlink" title="label语句"></a>label语句</h5><p>label语句可以在代码中添加标签，以便将来使用。</p>
<p>label: statement</p>
<p>一般都和for语句等循环语句配合使用</p>
<h5 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a>break和continue语句</h5><ul>
<li>break：立即退出循环，强制执行循环后面的语句。</li>
<li>continue：立即退出循环，从循环的顶部继续执行。</li>
</ul>
<h5 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h5><p>switch (expression) {</p>
<p>​    case value: statement</p>
<p>​        break;</p>
<p>​    case value: statement</p>
<p>​        break;</p>
<p>​    case …</p>
<p>​    default： statement</p>
<p>}</p>
<p>switch语句中每一种case的含义是，如果表达式等于这个值，则执行后面的语句，而break关键词会导致代码跳出switch语句，如果省略break关键字，就会导致当前case后，继续执行下一个case。 default关键字在于表达式不匹配前面任何一种情况时，执行机动代码。</p>
<p>switch在进行比较时，使用的是全等操作符</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h5><ul>
<li><code>function fName(args) {statements}</code></li>
<li><code>let fName = function(args) {statement}</code></li>
</ul>
<p>ECMAScript中的函数在定义时不必指定是否返回值，但任何函数任何时候都可以通过return语句后跟要返回的值来实现返回值。</p>
<p>位于return之后任何代码都不会执行，一个函数也可以包含多个return语句。</p>
<p>return语句也可以不带任何返回值，这时函数停止执行后返回undefined值，一般用于需要提前停止函数执行而又不需要返回值的情况下。</p>
<h5 id="理解参数"><a href="#理解参数" class="headerlink" title="理解参数"></a>理解参数</h5><p>ECMAScript中的参数在内部使用一个数组来表示，函数接受到的始终是这个数组，而不关心数组中包含哪些参数。在函数体内部可以通过arguments对象来访问这个参数数组。</p>
<p>arguments对象只是一个类数组，可以使用方括号语法访问他的每一个元素，使用length属性来确定传递进来多少个参数。</p>
<p>在ECMAScript中，命名的参数只提供便利 而不是必须。</p>
<p>arguments对象可以和命名参数一起使用，它的值永远和对应命名参数保持同步。</p>
<p>arguments中的值和对应的命名参数的内存空间是独立的，但是他们的值会同步。</p>
<p>没有传递值的命名参数会被自动赋予undefined值。</p>
<p>ECMAScript中所有参数传递的都是值，不可能通过引用传递参数。</p>
<h5 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h5><p>如果在ECMAScript中定义了两个名字相同的函数，则该名字只属于后定义的函数。</p>
<h2 id="4-变量、作用域和内存问题"><a href="#4-变量、作用域和内存问题" class="headerlink" title="4.变量、作用域和内存问题"></a>4.变量、作用域和内存问题</h2><h4 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h4><p>基本类型值是指简单的数据段，引用类型值指那些可能由多个值构成的对象。</p>
<p>Undefined，Null，Boolean，Number和String这五种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。</p>
<p>引用类型的值是保存在内存地址中的对象，是按引用访问的。</p>
<h5 id="动态的属性"><a href="#动态的属性" class="headerlink" title="动态的属性"></a>动态的属性</h5><p>对于引用类型，可以为其添加属性和方法，也可以改变和删除其属性和方法。</p>
<p>而不能给基本类型添加属性，尽管这样做不会导致任何错误。</p>
<h5 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h5><p>如果从一个向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到新变量分配的位置上。</p>
<p>而在复制引用类型时，复制的其实是对象的指针，两个变量实际引用同一个对象，改变其中一个变量，就会影响另一个变量。</p>
<h5 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h5><p>ECMAScript中所有的函数的参数都是<strong>按值传递</strong>的，基本类型值的传递就如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。</p>
<p>传递基本类型的值时，被传递的值会被复制给一个局部变量，在向参数传递引用类型时，会把这个值在内存中的地址复制给一个局部变量。</p>
<h5 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h5><p>检测基本数据类型：typeOf()</p>
<p>检测引用数据类型：variable instanceof constructor</p>
<p>如<code>[]  instanceof Array</code> 会返回true</p>
<p>如果使用instanceof操作符检测基本数据类型的值，则该操作符始终会返回false</p>
<h4 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h4><p>执行环境： 定义了变量或函数有权访问的其他数据，决定了它们各自的行为。当某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的变量和函数定义也随之销毁。</p>
<p>全局执行环境时最外围的一个执行环境，在web浏览器中，全局执行环境被认为是window对象，因此所有的全局变量和函数都是作为window对象的属性和方法创建的。全局执行环境直到应用程序退出时才会销毁。</p>
<p>每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，而在函数执行之后栈将其弹出，把控制权返回给之前的执行环境。</p>
<p>作用域连：当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途是保证对执行环境有权访问的所有的变量和函数的有序访问，作用域链的前端，始终是当前执行代码所在环境的变量对象，如果是函数，即为arguments对象。下一个变量对象为下一个包含环境，一直延伸到全局。</p>
<p>标示符解析是沿着作用域链一级一级地搜索表示服的过程。</p>
<h5 id="没有块级作用域"><a href="#没有块级作用域" class="headerlink" title="没有块级作用域"></a>没有块级作用域</h5><p>ECMAScript中，使用var声明的变量没有块级作用域，在if或for语句中声明的变量，在外部依然可以访问到。</p>
<ul>
<li>声明变量：使用var声明的变量会被自动添加到最接近的环境中，在函数内部，最接近的环境就是函数的局部作用域。如果没有使用var声明，则会被自动添加到全局环境。建议在初始化变量之前，一定要先声明。</li>
<li>查询标示符：搜索标示符的搜索过程从作用域的前端开始，向上逐级查询与给定名字匹配的标示符，即从局部环境向外搜索，如果局部变量中有同名标示符，就不会使用父环境中的标示符。</li>
</ul>
<h4 id="垃圾清理"><a href="#垃圾清理" class="headerlink" title="垃圾清理"></a>垃圾清理</h4><h5 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h5><p>JavaScript中最常用的垃圾收集方式是标记清楚，当变量进入环境时(如在函数中声明一个变量)，就将这个变量标记为“进入环境”，而当变量离开环境时，则将其标记为“离开环境”。</p>
<p>垃圾收集器在运行时会给储存在内存中的所有变量都加上标记，然后，他会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经午饭访问到的这些变量。最后垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</p>
<h5 id="管理内存"><a href="#管理内存" class="headerlink" title="管理内存"></a>管理内存</h5><p>一旦数据不再游泳，最好通过将其值设置为null来释放引用，这个做法叫解除引用。</p>
<p>解除一个值的引用并不意味着自动回收该值所占用的内存，解除引用的真正作用是让值脱离执行环境，以便让垃圾收集器下次运行时将其回收。</p>
<h2 id="5-引用类型"><a href="#5-引用类型" class="headerlink" title="5.引用类型"></a>5.引用类型</h2><p>对象是某个特定引用类型的实例。新对象是使用new操作符后跟一个构造函数来创建的。构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。</p>
<h4 id="Object类型-1"><a href="#Object类型-1" class="headerlink" title="Object类型"></a>Object类型</h4><h5 id="创建Object实例"><a href="#创建Object实例" class="headerlink" title="创建Object实例"></a>创建Object实例</h5><ul>
<li><p>使用new操作符后跟Object构造函数</p>
<p><code>var obj = new Object()</code></p>
</li>
<li><p>使用<strong>对象字面量</strong>表示法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">	name: &#39;simon&#39;,</span><br><span class="line">	age: 22</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用对象字面量语法时，属性名也可以使用字符串。</p>
<p>使用对象字面量语法时，如果留空其花括号，则可以定义只包含默认属性和方法的对象。</p>
<p>关于对象字面量语法，推荐只在考虑对象属性名的可读性时使用，在通过对象字面量定义对象时，实际上不会调用Object构造函数。</p>
<p>对象字面量时向函数传递大量可选参数的首选方式。</p>
</li>
</ul>
<h5 id="访问对象属性"><a href="#访问对象属性" class="headerlink" title="访问对象属性"></a>访问对象属性</h5><ul>
<li>点表示法 <code>obj.name</code></li>
<li>方括号表示法  <code>obj[&quot;name&quot;]</code></li>
</ul>
<p>方括号访问法可以通过变量来访问对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var propertyName &#x3D; &quot;age&quot;</span><br><span class="line">obj[&quot;propertyName&quot;] &#x2F;&#x2F;22</span><br></pre></td></tr></table></figure>

<p>如果属性名中包含会导致语法错误的字符(如空格)，或者属性名使用的关键字或保留字，也可以使用方括号表示法</p>
<p><strong>除非必须使用变量来访问属性，否则建议使用点表示法</strong></p>
<h4 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h4><h5 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h5><ul>
<li><p>Array构造函数</p>
<p><code>let arr = new Array(length)</code></p>
<p>可以预先给构造函数传递length值，会创建一个length为该数值的数组。</p>
<p>也可以传递数组中应该包含的项。</p>
<p>new操作符可以省略。</p>
</li>
<li><p>数组字面量表示法</p>
<p><code>let arr = [1,2,3]</code></p>
<p>使用数组字面量表示法时，也不会调用Array构造函数。</p>
</li>
</ul>
<p>读取和设置数组时，使用方括号并提供相应值的基于0的数字索引，设置数组的值也使用相同的语法，如果该索引位置有值则替换该值，如果索引超过数组的现有项数，则自动增加到该索引值加1的长度。</p>
<p>数组的lengrh属性不是只读的，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var color &#x3D; [&#39;red&#39;,&#39;blue&#39;,&#39;green&#39;]</span><br><span class="line">color.length &#x3D; 2 &#x2F;&#x2F;移除了最后一项</span><br><span class="line">color[color.length] &#x3D; &#39;yellow&#39;  &#x2F;&#x2F; 在末尾添加了一项</span><br></pre></td></tr></table></figure>

<h5 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h5><ul>
<li><code>value instanceof Array</code></li>
<li><code>Array.isArray(value)</code></li>
</ul>
<h5 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h5><ul>
<li>valueOf()：返回数组本身</li>
<li>toString()：返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串</li>
<li>join()方法： 接受一个参数，使用这个参数来构建将数组分割成字符串。</li>
</ul>
<h5 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h5><ul>
<li><p>push()：在末尾添加多项并返回长度</p>
</li>
<li><p>pop()：移除并返回末尾的一项</p>
</li>
</ul>
<h5 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h5><ul>
<li><p>shift()：移除并返回第一项</p>
</li>
<li><p>unshift()：在数组前添加多项并返回长度</p>
</li>
</ul>
<h5 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h5><ul>
<li><p>reverse()：反转数组的顺序并返回</p>
</li>
<li><p>sort()：接收一个比较函数，比较函数返回负数，则第一个参数排在第二个参数之前。返回0。则不变，返回正数，则第二个参排在第一个参数之前。返回排序后的数组。</p>
</li>
</ul>
<h5 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h5><ul>
<li><p>concat()：不改变原数组</p>
<ul>
<li>不传参，复制数据并返回副本。</li>
<li>传参数组或其他值，添加到数组之后并返回新数组。</li>
</ul>
</li>
<li><p>slice()： 不改变原数组</p>
<ul>
<li>一个参数，返回该项到末尾的所有参数组成的数组。</li>
<li>两个参数，返回该项到结束位置(不包含结束位置)的所有项。</li>
</ul>
<p>如果slice()方法的参数中有一个负数，则用数组长度加上该数来确定位置。</p>
</li>
<li><p>splice()：改变原数组，返回值为删除的项。</p>
<ul>
<li>删除，两个参数，要删除的第一项，要删除的项数。</li>
<li>插入，三个参数，要插入的位置，0，要插入的元素。</li>
<li>替换，三个参数，要插入的位置，要删除的项数，替换成的元素。</li>
</ul>
</li>
</ul>
<h5 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h5><ul>
<li>indexOf()</li>
<li>lastIndexOf()</li>
</ul>
<p>接收两个参数，要查找的项，表示起点位置的索引，indexOf()从头往后找，lastIndexOf()从后向前找，返回查找项在数组中的索引，没找到则返回-1。使用全等进行比较。</p>
<h5 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h5><p>每个方法都接收两个参数，要在每一项上运行的函数和运行该函数的作用域对象-this的值(可选)。</p>
<p>作为参数的函数，有三个参数，分别是具体的每一项item，该项的索引index，原数组array。</p>
<ul>
<li>every()：对数组中的每一项运行给定的函数，如果该函数对每一项都返回true，则返回true。</li>
<li>filter()：对数组中的每一项运行给定的函数，返回该函数会返回true的项数组成的数组。</li>
<li>forEach()：对数组中的每一项运行给定的函数。这个方法没有返回值。</li>
<li>map()：对数组中的每一项运行给定的函数，返回每次调用的结果组成的数组。</li>
<li>some：对数组中的每一项运行给定的函数，如果函数对任一项返回true，则返回true。</li>
</ul>
<h5 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h5><ul>
<li>reduce()</li>
<li>reduceRight()</li>
</ul>
<p>两个方法都会迭代数组中的所有项，然后构建一个最终返回的值，都接受两个参数，在每项上调用的函数和作为归并的基础值。</p>
<p>作为参数的函数接收4个参数，前一个值，当前值，项的索引和数组对象，这个函数返回的任何值都会作为第一个参数自动传给下一项，第一次迭代发生在第二项上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let values &#x3D; [1,2,3,4,5]</span><br><span class="line">let sum &#x3D; values.reduce((pre,cur,index,array)&#x3D;&gt; prev + cur)</span><br></pre></td></tr></table></figure>

<h5 id="ES6新增"><a href="#ES6新增" class="headerlink" title="ES6新增"></a>ES6新增</h5><ul>
<li><p>find()</p>
<p>参数为一个回调函数，为所有数组的成员执行该函数，直到找到一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</p>
<p>回调函数接收三个参数，当前项，当前的位置和原数组</p>
</li>
<li><p>findIndex()</p>
<p>和find()方法类似，返回第一个符合条件的数组成员的位置，没找到则返回-1。</p>
</li>
<li><p>fill()</p>
<p>接收三个参数，填充值，填充的起始位置和填充的结束位置，后两个参数可选，如果没有后面两个参数，则将所有项都替换为填充值。</p>
<p><code>new Array(3),fill(1) // [1,1,1]</code> 用于空数组的初始化时很方便。</p>
</li>
<li><p>entries()，keys()，values()</p>
<p>用于便利数组，返回一个可用for…of遍历的迭代器对象，keys()是对键名的遍历，values()是对键值的遍历，entries()是对键值对的遍历。</p>
</li>
</ul>
<h4 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h4><p>Date类型能精确到1970年1月1号前后的1000000000天。</p>
<h5 id="创建日期对象"><a href="#创建日期对象" class="headerlink" title="创建日期对象"></a>创建日期对象</h5><p><code>let now = new Date()</code></p>
<p>在不传参的情况下，会自动获取当前的时间，如果想创建特定的日期，传参该日期的距1970年1月1日的毫秒数。</p>
<ul>
<li><p>Date.parse()</p>
<p>接受一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。</p>
</li>
<li><p>Date.UTC()</p>
<p>接收参数分别为年份，基于0的月份，月中的哪一天，小时数，分钟，秒和毫秒数。</p>
</li>
<li><p>Date.now()</p>
<p>返回当前的时间毫秒数。</p>
</li>
<li><p>+new Date()</p>
<p>和Data.now()取得相同的值。</p>
</li>
</ul>
<h5 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h5><ul>
<li><p>toLocalString()</p>
<p>按照浏览器设置的的确相适应的格式返回日期和时间</p>
</li>
<li><p>toString()</p>
<p>返回带有时区信息的日期和时间</p>
</li>
<li><p>valueOf()</p>
<p>返回日期的毫秒表示。方便比较操作符来比较日期大小。</p>
</li>
</ul>
<h5 id="实例的常用方法"><a href="#实例的常用方法" class="headerlink" title="实例的常用方法"></a>实例的常用方法</h5><ul>
<li>getTime() 返回日期的毫秒数，和vauleOf()返回值相同</li>
<li>setTime() 以毫秒数设置日期</li>
<li>getFullYear() 返回四位数年份</li>
<li>setFullYear() 设置四位数年份</li>
<li>getMonth() 返回0-11的月份</li>
<li>getDate() 返回天数</li>
<li>getHours() 返回小时数</li>
<li>getMinutes() 返回分钟数</li>
<li>getSeconds 返回秒数</li>
<li>getMillisecond 返回毫秒数</li>
</ul>
<h4 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h4><p>ECMAScript通过REgExp来支持正则表达式。</p>
<h5 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h5><ul>
<li><p>字面量</p>
<p><code>let expression = /pattern/ flag</code></p>
</li>
<li><p>RegExp构造函数</p>
<p><code>let expression2 = new RegExp(&quot;pattern&quot;,&quot;flag&quot;)</code></p>
</li>
</ul>
<p>模式（pattern）可以是任何正则表达式，每个正则表达式都可以带一个或多个标志（flag）</p>
<p>三个flag如下：</p>
<ul>
<li>g 全局模式，模式被用于全局 而不是在发现第一个匹配项时立即停止。</li>
<li>i 不区分大小写</li>
<li>m 多行匹配</li>
</ul>
<h5 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h5><ul>
<li><p>exec()：专门为捕获组而生，接受应用模式的字符串作为参数，返回包含第一个匹配信息的数组，没有匹配项则返回null。 返回的数组包含两个额外属性，input 应用正则表达式的字符串和index 匹配项在字符串中的位置。</p>
</li>
<li><p>test()：接受一个字符串参数，再模式与该参数匹配的情况下返回true，否则返回false。</p>
</li>
</ul>
<h4 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h4><p><strong>函数实际上是对象</strong>，与其他引用类型一样具有属性和方法，<strong>函数名实际上也是一个指向函数对象的指针</strong>，不会和某个函数绑定(没有重载，后面的同名函数会覆盖前面的函数)。</p>
<h5 id="定义函数-1"><a href="#定义函数-1" class="headerlink" title="定义函数"></a>定义函数</h5><ul>
<li><p>函数声明语法</p>
<p><code>function fName (args) {...}</code></p>
</li>
<li><p>函数表达式</p>
<p><code>let fName = function(args) {...}</code></p>
</li>
<li><p>构造函数</p>
<p><code>let fName = new Function(arg1,arg2,...,“函数体”) //不推荐</code></p>
</li>
</ul>
<p><strong>函数声明语法定义的函数具有变量提升，使用表达式构建的函数没有变量提升。</strong></p>
<p>函数可以作为参数传递，也可以作为函数的结果返回。</p>
<h5 id="函数的内部属性"><a href="#函数的内部属性" class="headerlink" title="函数的内部属性"></a>函数的内部属性</h5><ul>
<li>arguments：保存函数参数的类数组。</li>
<li>arguments.callee：指向函数本身。</li>
<li>this：指向函数执行的环境对象，再全局作用域下，指向window。</li>
<li>caller：指向调用当前函数的函数。</li>
</ul>
<h5 id="函数的属性和方法"><a href="#函数的属性和方法" class="headerlink" title="函数的属性和方法"></a>函数的属性和方法</h5><ul>
<li>length：函数希望接受的命名参数的个数。</li>
<li>prototype：保存所有实例方法的正真所在。</li>
<li>apply()：接收两个参数，一个是this的值，一个是arguments数组。</li>
<li>call()：接收多个参数，第一个是this的值，一个是逐个列举的参数。</li>
<li>bind()：接收一个this的值，返回一个新的函数，其this被绑定到该参数上。</li>
<li>toString()和toLocalString() 返回函数的源代码。</li>
</ul>
<h4 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h4><p>为了方便基本类型值，ECMAScript提供了3个特殊的引用类型Boolean，Number，和String。</p>
<p><strong>当读取一个基本类型的值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们可以调用一些方法来操作这些数据。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &quot;some text&quot;</span><br><span class="line">let str1 &#x3D; str.substring(2)</span><br><span class="line">&#x2F;&#x2F;相当于执行了一下几步</span><br><span class="line">&#x2F;&#x2F;1.创建string类型的一个实例</span><br><span class="line">&#x2F;&#x2F;2.在实例上调用指定的方法</span><br><span class="line">&#x2F;&#x2F;3.销毁这个实例</span><br><span class="line">let str &#x3D; new String(&quot;some text&quot;)</span><br><span class="line">let str1 &#x3D; str.subString(2)</span><br><span class="line">str &#x3D; null</span><br></pre></td></tr></table></figure>

<p>引用类型和基本包装类型的主要区别是生存期，使用new操作符创建的阴影类型的实例，在执行流离开当前作用域之前都一直保存在内存中，而自动创建的基本包装类型的对象，则只存在代码执行的一瞬间，然后立即被销毁，因此我们无法在运行时为基本类型添加属性和方法。</p>
<h5 id="Boolean类型-1"><a href="#Boolean类型-1" class="headerlink" title="Boolean类型"></a>Boolean类型</h5><p>别用</p>
<h5 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h5><ul>
<li>valueOf()：返回数值</li>
<li>toString()：传递一个表示基数的参数，告诉它返回几进制的数值的字符串形式。</li>
<li>toFixed()：按照指定的小数位返回数值的字符串表示。</li>
<li>toExponential()：返回指数表示法数值的字符串，接受一个参数，表示结果中的小数位数。</li>
<li>toPrecision()：接受一个参数，表示数值的所有数值的位数（不包括指数部分），会返回固定位数或指数格式中最合适的那个。</li>
</ul>
<h5 id="String类型-1"><a href="#String类型-1" class="headerlink" title="String类型"></a>String类型</h5><ul>
<li>length：字符串中的字符数量。</li>
<li>charAt()和charCodeAt()：接受一个基于0的索引，charAt()返回该位置的字符，charCodeAt()返回该位置字符的字符编码。</li>
<li>[index]：访问指定位置的字符串。</li>
<li>concat()：接受任意多个参数，将一个或多个字符串拼接起来，返回拼接得到的字符串。</li>
<li>slice()：第一个参数表示新字符串开始位置，第二个参数为结束位置(不包括该位置)。</li>
<li>substring()：较小的参数表示新字符串开始位置，较大的参数为结束位置(不包括该位置)。</li>
<li>substr()：第一个参数表示新字符串的开始位置，第二个参数是返回的字符串的长度。</li>
</ul>
<p>多数情况下，以上三个方法返回的结果相同，但在传递负值时，slice()将传入的负值和字符串的长度相加，substr()将第一个负值和长度相加，将第二个负值转换为0，substring将所有负值都转换为0。</p>
<ul>
<li><p>indexOf()和lastIndexOf()：从一个字符串中搜索给定的子字符串，然后返回子字符串的位置（如果没有找到则返回-1），两个方法都接受可选的第二个参数，表示从子字符串中的哪个位置开始搜索。</p>
</li>
<li><p>toLowerCase() toUpperCase()</p>
</li>
<li><p>match()：接受一个正则表达式或RegExp对象，返回一个数组，第一项是整个模式匹配的字符串，之后的每一项保存着与正则表达式中捕获组匹配的字符串。</p>
</li>
<li><p>search()：接受正则表达式作为参数，返回字符串中第一个匹配项的索引，没有则返回-1。</p>
</li>
<li><p>replace()：接受两个参数，第一个为正则表达式或字符串，第二个为字符串或函数。如果第一个值是一个字符串，那么只会替换第一个子字符串，想要替换所有字符串，唯一的办法就是提供一个正则表达式，而且要指定全局标志(g)。</p>
<p>第二个参数是函数时，这个函数有三个参数，分别是模式的匹配项，模式匹配项在字符串中的位置和原始字符串。</p>
</li>
<li><p>split()：基于指定的分隔符将字符串拆分成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个正则表达式。这个方法还接受第二个参数，用于指定数组的大小。</p>
</li>
</ul>
<h5 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h5><p>不属于任何对象的属性和方法，最终都是他的属性和方法</p>
<ul>
<li>encodeURIComponent() 和encodeURI()：对URI进行编码</li>
<li>decodeURIComponent() 和 decodeUR(): 对URI进行解码</li>
<li>eval(): 执行接受的ECMAScript字符串。</li>
</ul>
<p>特殊值null，undefined，NaN，Infinity都是Global的属性，所有的原生引用类型的构造函数，如Object、Function，也都是Global的属性。</p>
<ul>
<li>window对象：web浏览器将Global作为window的一部分来实现，在全局作用域中声明的所有函数和变量都是window对象的属性。</li>
</ul>
<h5 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h5><ul>
<li><p>min()和max()返回一组数值中的最小值和最大值。</p>
<p><code>Math.min.applay(Math,arr) //返回数组中的最大最小值</code></p>
</li>
<li><p>ceil()：向上取整</p>
</li>
<li><p>floor()： 向下取整</p>
</li>
<li><p>round()：四舍五入</p>
</li>
<li><p>random()：返回[0,1)的一个随机数</p>
<p><code>Math.floor(Math.random()* 可能值的总数 + 第一个值) // 在范围内随机选择一个值</code></p>
</li>
</ul>
<h4 id="6-面向对象的程序设计"><a href="#6-面向对象的程序设计" class="headerlink" title="6.面向对象的程序设计"></a>6.面向对象的程序设计</h4><p>对象是无序属性的集合，其属性可以包含基本值、对象或者函数。</p>
<h5 id="数据属性-包含一个数据值的位置，在这个位置可以读取和写入值，有4个描述其行为的特性"><a href="#数据属性-包含一个数据值的位置，在这个位置可以读取和写入值，有4个描述其行为的特性" class="headerlink" title="数据属性 包含一个数据值的位置，在这个位置可以读取和写入值，有4个描述其行为的特性"></a>数据属性 包含一个数据值的位置，在这个位置可以读取和写入值，有4个描述其行为的特性</h5><ul>
<li>[[Configurable] ：能否通过delete删除属性，从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性，默认值为false(修改之后无法再被修改)。</li>
<li>[[Enumerable]]：能否通过for-in遍历对象返回属性，默认为true。</li>
<li>[[Weitable]]：能否修改属性的值，默认为true。</li>
<li>[[value]]：包含这个属性的数据值，默认为undefined。</li>
</ul>
<p>修改数据属性的特性：Object.defineProperty()</p>
<p>接受三个参数，属性所在的对象，属性的名字，包含描述符特性的对象(configurable,enumerable,writable,value)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(obj,&#39;name&#39;,&#123;</span><br><span class="line">	writable: false,</span><br><span class="line">	value: &#39;simon&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="访问器属性-包含一对getter和setter函数，不包含数值-这两个函数非必须"><a href="#访问器属性-包含一对getter和setter函数，不包含数值-这两个函数非必须" class="headerlink" title="访问器属性 包含一对getter和setter函数，不包含数值(这两个函数非必须)"></a>访问器属性 包含一对getter和setter函数，不包含数值(这两个函数非必须)</h5><ul>
<li>[[Configurable]]：…</li>
<li>[[Enumerable]]：…</li>
<li>[[Get]]：在读取是调用的函数</li>
<li>[[Set]]：在写入属性时调用的函数</li>
</ul>
<p>访问器函数不能直接定义，必须通过Object.defineProperty()来定义，但一次只能定义一个属性。Object.definePrototyies()可以一次定义多个属性。</p>
<p>访问器属性最常见的用法是，设置一个属性的值会导致其他属性发生变化。</p>
<h5 id="读取属性"><a href="#读取属性" class="headerlink" title="读取属性"></a>读取属性</h5><p>Object.getOwnPropertyDesciptor()接受两个参数，属性所在的对象和要读取其描述符的属性名称。</p>
<h5 id="创建对象-1"><a href="#创建对象-1" class="headerlink" title="创建对象"></a>创建对象</h5><p>Object 构造函数或对象字面量来创建单个对象时：使用同一个接口创建很多对象，会产生大量重复代码。</p>
<ul>
<li><p>工厂模式</p>
<p>工厂模式是用一个函数封装以创建对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name,age,job) &#123;</span><br><span class="line">	let o &#x3D; new Object()</span><br><span class="line">	o.name &#x3D; name</span><br><span class="line">	o.age &#x3D; age</span><br><span class="line">	o.job &#x3D; job</span><br><span class="line">	o.sayName &#x3D; function() &#123;</span><br><span class="line">		alert(this.name)</span><br><span class="line">	&#125;</span><br><span class="line">	return o</span><br><span class="line">&#125;</span><br><span class="line">let person1 &#x3D; createPerson(&#39;Simon&#39;,22,&#39;student&#39;)</span><br></pre></td></tr></table></figure>

<p>工厂模式解决了创建多个相似对象的问题，但没有解决对象识别的问题(即怎样知道对象的类别)</p>
</li>
<li><p><strong>构造函数模式</strong></p>
<p>ECMAScript中的构造函数可用来创建特定类型的对象。像Object和Array这样的原生构造函数，会在运行时自用出现在执行环境中。此外，也可以自定义创建构造函数，从而定义自定义对象类型的属性和方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job) &#123;</span><br><span class="line">	this.name &#x3D; name</span><br><span class="line">	this.age &#x3D; age</span><br><span class="line">	this.job &#x3D; job</span><br><span class="line">	this.sayName &#x3D; function() &#123;</span><br><span class="line">		slert(this.name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let person &#x3D; new Person(&#39;simon&#39;,22,&#39;student&#39;)</span><br></pre></td></tr></table></figure>

<p>构造函数始终以一个大写字母开头，而非构造函数以小写字母开头。</p>
<p>构造函数本身也是函数，只不过可以用来创建对象。</p>
<p>要创建构造函数的实例，必须使用new操作符。</p>
<p><strong>new的过程</strong></p>
<ul>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋给新对象(this指向这个新对象)</li>
<li>执行构造函数中的代码(为这个新对象添加属性)</li>
<li>返回新对象</li>
</ul>
<p>每一个实例都有constructor(构造函数)属性，指向创建实例的构造函数。使用 instanceof操作符，可以判断实例是否是某个构造函数的实例。</p>
<p><strong>创建自定义构造函数意味着将来可以将他的实例标示为一种特定的类型。</strong></p>
<p><strong>构造函数也是函数</strong></p>
<p>构造函数和其他函数的区别在于调用他们的方式不同，任何函数，只要通过new操作符调用，就可以当作构造函数，构造函数也可以不使用new，当作普通函数来使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.构造函数new调用</span><br><span class="line">let person &#x3D; new Person(&#39;simon&#39;,22,&#39;studernt&#39;)</span><br><span class="line">person.sayName() &#x2F;&#x2F; &#39;simon&#39;</span><br><span class="line">&#x2F;&#x2F; 2.作为普通函数使用</span><br><span class="line">Person(&#39;simon&#39;,&#39;22&#39;,&#39;student&#39;)</span><br><span class="line">window.sayName()  &#x2F;&#x2F; 被添加到全局作用域的this 浏览器中为window</span><br><span class="line">&#x2F;&#x2F; 3.在另一个对象的作用域中调用</span><br><span class="line">let o &#x3D; new Object()</span><br><span class="line">Person.call(o,&#39;simon&#39;,22,&#39;student&#39;)</span><br><span class="line">o.sayName() &#x2F;&#x2F; &#39;simon&#39;</span><br></pre></td></tr></table></figure>

<p><strong>构造函数的问题</strong></p>
<p>构造函数的主要问题每个方法都要在每个实例上重新创建一遍，可以通过将函数转移到外部来解决。但一般使用原型来定义方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person(...) &#123;</span><br><span class="line">	...</span><br><span class="line">	this.sayName &#x3D; sayName</span><br><span class="line">&#125;</span><br><span class="line">function sayName() &#123;</span><br><span class="line">	return this.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>原型模式</p>
<p>我们创建的每一个函数都有一个prototype属性，这个属性指使用该函数创建的实例对象的原型对象，他的用途是包含实例可以共享的属性和方法，而不必在构造函数中定义。而这些实例访问的方法是同一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName &#x3D; function() &#123;</span><br><span class="line">	return this.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。默认情况下，所以原型对象都会自动获得一个<strong>constructor</strong>属性，这个属性指向prototype属性所在的函数。</p>
<p>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针[[prototype]]，指向构造函数的原型对象，使用属性_<em>proto_\</em> 可以实现这个属性的访问。</p>
<p>isPrototypeOf() 确定原型是否是对象实例的原型</p>
<p><code>Person.ptototype.isPrototypeOf(person1) // true</code></p>
<p>Object.getPrototypeOf() 返回实例的[[prototype]]的值</p>
<p><code>Object.getPrototypeOf(person1.nmae  //&#39;simon&#39;</code></p>
<p><strong>在访问对象属性时，首先搜素实例本身，如果没有则搜索原型对象。</strong></p>
<p><strong>虽然可以通过对象实例访问保存在原型中的值，但却不能通过实例重写原型中的值。</strong></p>
<p>当为实例对象添加属性时，这个属性会阻止我们访问原型中的属性，但不会修改那个属性，使用delete操作符可以删除实例属性，从而让我们能重新访问原型中的属性。</p>
<p>hasOwnProperty() 可以检测一个属性时在实例中还是在原型中，只有属性存在于实例中才返回true。</p>
<p><code>person1.hasOwnProperty(&#39;name&#39;) // true</code></p>
<p>使用for-in循环，会返回所有能够通过对象访问的、可枚举属性，其中既包括实例中的属性，又包括原型中的属性。</p>
<p>单独使用in操作符，会在通过对象能访问给定的属性时，返回true。</p>
<p>同时使用hasOwnPorperty() 和 in操作符 就可以确定属性到底是存在于对象中，还是存在于原型中。</p>
<p><code>!person1.hasOwnProperty(&#39;name&#39;) &amp;&amp; (name in person1)</code></p>
<p><strong>原型的动态性</strong></p>
<p>我们对原型所做的任何修改都能立即从实例上反映出来。实例和原型之间的连接时一个指针，而不是副本，通过搜索链来调用。</p>
<p>如果重写了整个原型对象，那么就切断了构造函数和最初原型之间的联系。构造函数的prototype指向新的对象。<strong>实例中的指针仅指向原型，而不指向构造函数。</strong>而实例的[[prototype]]依旧指向最初的原型对象。</p>
<p><strong>原生对象的原型</strong></p>
<p>所有的原生引用类型(Array、Object、String等)都在其构造函数的原型对象上定义了方法。</p>
<p>通过原生对象的原型，可以取得所有默认方法的应用，还可以定义新方法，原生对象的原型的方法。但不推荐修改原生对象的原型。</p>
<p><strong>原型对象的问题</strong></p>
<p>原型模式省略了为构造函数传递初始化参数的过程，所有实例在默认情况下都取得了相同的属性。修改一个实例的<strong>引用类型属性</strong>的值，使所有实例取得的值都被改变了 。</p>
<p><strong>组合使用构造函数和原型模式</strong></p>
<p>使用构造函数来定义实例属性，使用原型模式来定义方法和共享的结果。</p>
<p>这种构造函数和原型混成的模式，是目前在ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法。是用来定义引用类型的一种默认模式。</p>
</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">chenmoonmo@gmail.com</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://chenmoonmo.github.io/2020/06/24/js%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">http://chenmoonmo.github.io/2020/06/24/js%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/07/09/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"><i class="fa fa-chevron-left">  </i><span>7.8 面试总结</span></a></div><div class="next-post pull-right"><a href="/2020/06/20/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"><span>服务器相关知识</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By chenmoonmo@gmail.com</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>